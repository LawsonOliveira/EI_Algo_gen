import sys  
from pathlib import Path  
file = Path(__file__).resolve()  
package_root_directory = file.parents[1]  
sys.path.append(str(package_root_directory))

#For computing
import mathutils
import math

#For drawing
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import collections  as mc
import copy

class Traj3D:
    """Represents a 3D trajectory"""

    # Vertical translation (elevation) between two di-nucleotides
    __MATRIX_T = mathutils.Matrix.Translation((0.0, 0.0, 3.38/2.0, 1.0))

    def __init__(self):
        self.__Traj3D = {}

    def getTraj(self):
        # Return the trajetory 3D of the sequence
        return self.__Traj3D

    def compute(self, dna_seq, rot_table):
        # Matrix accumulating all the geometrical transformations generated by the DNA sequence
        total_matrix = mathutils.Matrix()

        # We record the position of the first nucleotide
        self.__Traj3D = [mathutils.Vector((0.0, 0.0, 0.0, 1.0))]

        matrices_Rz = {}
        matrices_Q = {}
        # We go through the sequence, nucleotide by nucleotide
        for i in range(1, len(dna_seq)):
            # On lit le dinucleotide courant
            dinucleotide = dna_seq[i-1]+dna_seq[i]
            # We fill in the rotation matrices as we go along
            if dinucleotide not in matrices_Rz:
                matrices_Rz[dinucleotide] = mathutils.Matrix.Rotation(math.radians(rot_table.getTwist(dinucleotide)/2), 4, 'Z')
                matrices_Q[dinucleotide] = \
                    mathutils.Matrix.Rotation(math.radians((rot_table.getDirection(dinucleotide)-90)), 4, 'Z') \
                    @ mathutils.Matrix.Rotation(math.radians((-rot_table.getWedge(dinucleotide))), 4, 'X') \
                    @ mathutils.Matrix.Rotation(math.radians((90-rot_table.getDirection(dinucleotide))), 4, 'Z')


            # We calculate the geometric transformations according to the current dinucleotide, and we add them to the total matrix
            total_matrix =  total_matrix @ \
                self.__MATRIX_T \
                @ matrices_Rz[dinucleotide] \
                @ matrices_Q[dinucleotide] \
                @ matrices_Rz[dinucleotide] @ \
                self.__MATRIX_T

            # The position of the current nucleotide is calculated by applying all geometrical transformations to the position of the first nucleotide
            self.__Traj3D.append(total_matrix @ self.__Traj3D[0])


    def draw(self, filename): # Draw the graph
        xyz = np.array(self.__Traj3D)
        self.__Traj3D = []
        x, y, z = xyz[:,0], xyz[:,1], xyz[:,2]
        fig = plt.figure()
        ax = fig.add_subplot(111, projection='3d')
        ax.plot(x,y,z)
        ax.scatter(x[-1],y[-1],z[-1],marker="x",c="red")
        plt.show()
        plt.savefig(filename)
